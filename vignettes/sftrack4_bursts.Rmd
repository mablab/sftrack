---
title: "4. Fantastic Bursts and how to use them"
output:
  html_document:
    toc: true
    toc_float:
      collapsed: false
      smooth_scroll: false
    toc_depth: 2
vignette: >
  %\VignetteIndexEntry{4. Fantastic Bursts and how to use them}
   %\VignetteEncoding{UTF-8}
   %\VignetteEngine{knitr::rmarkdown}
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

```

## Bursts  

Bursts are a big emphasis in `sftrack`. Structurally they are built with in the same vein as `sfc` and `sfg` classes in `sf`. 

To begin an `ind_burst` is a singular burst. Its whats stored at the row level. 
A `multi-burst` is a collection of `ind_bursts` and exists at the column level. Bursts also have an `active_burst` argument, which turns on and off certain bursts for analysis and plotting purposes.

We start by looking at the structure of a `multi_burst`
```{r}
#devtools::load_all("/home/matt/r_programs/sftrack")
library(sftrack)
data('raccoon', package = 'sftrack')
#raccoon <- read.csv(system.file('extdata/raccoon_data.csv', package='sftrack'))
burst_list = list(id = raccoon$animal_id, month = as.POSIXlt(raccoon$timestamp)$mon+1)

mb1 <- make_multi_burst(x=burst_list, active_burst=c('id','month'))
str(mb1)
mb1[[1]]
```

A burst contains grouping information. The `id` of the subject/sensor is the lowest level of grouping for the data. Any additional grouping variables are optional. 

A multi_burst is simply a collection of `ind_bursts`. The `ind_burst` is where the grouping data is stored, and can be modified at the row level. The `ind_bursts` main job is the store and maintain consistency of the grouping variables.

#### Basics

##### ind_bursts 
An ind_burst is the grouping variables for a single row of data.  

You can make an `ind_burst` object using `make_ind_burst()`, and giving it a list with the burst variables named. In this example we have a single sensor named 'TTP_058' from a raccoon, and an additional grouping variable of month (entered as its numeric interpretation).

All grouping information is converted and stored as a character in the ind_burst.

```{r}

indb <- make_ind_burst(list(id='TTP_058', month = 4))
str(indb)
```

Because `ind_burst`s are simply lists, you can edit individual elements in an ind_burst
```{r}
indb 
indb[1] <- 'CJ15'
indb$month <- '5'
str(indb)
```

##### multi_burst  
Multi_bursts are a collection of ind_bursts with the same grouping names and one 'active_burst' activated.

Similarly to ind_burst you can make a multi_burst with `make_multi_burst()`. The argument `burst` takes a list where each element is a vector indicating the named burst as well as a vector of the active bursts.

```{r}
burst_list <- list(id = rep(1:2,10), year = rep(2020, 10))
mb <- make_multi_burst(x=burst_list, active_burst=c('id','year'))
str(mb)
```

You can also make a multi_burst by concatenating multiple ind_bursts. All `ind_bursts` must have the same names or an error is returned.

```{r}
a <- make_ind_burst(list(id = 1, year = 2020))
b <- make_ind_burst(list(id = 1, year = 2021))
c <- make_ind_burst(list(id = 2, year = 2020))
mb <- c(a, b , c)

summary(mb)
```

You can also combine multi_bursts together with `c()`. All names and active_bursts must be the same.  

```{r}
mb_combine <- c(mb,mb)
summary(mb_combine)
```
You can also edit bursts like a list, but you must replace it with an object of the appropriate class and active_burst
```{r}
mb[1]
mb[1] <- make_ind_burst(list(id=3,year=2019))
mb[1]

```

And the burst names must match the ones in the multi_burst
```{r}
# Try to add an ind_burst with a month field when the original burst had year instead 
try( mb[1] <- make_ind_burst(list(id=3,month=2019)) )
```

##### selecting a burst

As `multi_burst`s are stored as lists, it can be difficult to refer to a single burst or group of bursts. This is where the sort_index can come in handy. The sort_index is a factor of the combined active_burst variables for each row (where paste(id, name1,name2,...,sep='_')). The burst label is remade everytime an active burst changes, and therefore can be used to subset. Using `burst_label()` you can access the sort_index. 

```{r}
burst_list <- list(id = rep(1:2,10), year = rep(2020, 10))
mb <- make_multi_burst(x=burst_list, active_burst=c('id','year'))
burst_labels(mb)[1:10]

# Subsetting a particular sensor from our raccoon data

#raccoon <- read.csv(system.file('extdata/raccoon_data.csv', package='sftrack'))
data('raccoon', package = 'sftrack')
raccoon$month <- as.POSIXlt(raccoon$timestamp)$mon+1

raccoon$time <- as.POSIXct(raccoon$timestamp, tz='EST')
coords = c('longitude','latitude')
burst = list(id = raccoon$animal_id, month = as.POSIXlt(raccoon$timestamp)$mon+1)
time = 'time'

my_sftraj <- as_sftraj(data = raccoon, coords = coords, burst = burst, time = time)
head(my_sftraj[burst_labels(my_sftraj) %in% c('TTP-058_1'), ])


```

You can also subset by entering the burst label of the burst itself in either the multi_burst or the sftrack/sftraj object:

```{r}
head(mb['1_2020'])

sub <- my_sftraj['TTP-058_1',]
print(sub,5, 3)
```
##### active_burst 
The active_burst is a simple yet powerful feature. It dictates how your raccoon is grouped for essentially all calculations. It can also be changed on the fly. You can view and change the active_burst of a multi_burst with `active_burst()`. Once changed, it recalculates the sort_index and in some cases recalculates the geometries.

Active_bursts can be changed for any sftrack/straj/multi_burst

```{r}
# sftrack
active_burst(my_sftraj)
summary(my_sftraj, stats = T)
active_burst(my_sftraj) <- c('id')
active_burst(my_sftraj)
summary(my_sftraj, stats = T)

# multi_burst
active_burst(mb)
active_burst(mb) <- 'id'
active_burst(mb)

```
